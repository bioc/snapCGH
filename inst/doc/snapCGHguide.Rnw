%\VignetteIndexEntry{Segmentation Overview}
%\VignetteDepends{limma, DNAcopy, GLAD}
%\VignetteKeywords{Segmentation, aCGH}
%\VignettePackage{snapCGH}

\documentclass[11pt,a4paper]{article}

\title{Sample of aCGH analysis}
\author{ML Smith}

%\settocname{Table of Contents}

\setlength{\oddsidemargin}{0.5cm} %margin
\setlength{\evensidemargin}{0.5cm} %margin
\setlength{\textwidth}{15.2cm}
\addtolength\footskip{1cm}
\pagestyle{plain}

\newcommand{\Robject}[1]{{\texttt{#1}}}
\newcommand{\Rfunction}[1]{{\texttt{#1}}}
\newcommand{\Rpackage}[1]{{\textit{#1}}}
\newcommand{\Rclass}[1]{{\textit{#1}}}
\newcommand{\Rmethod}[1]{{\textit{#1}}}
\newcommand{\Rfunarg}[1]{{\textit{#1}}}

\usepackage{Sweave}

\begin{document}

\maketitle

\section{Introduction}
This document outlines some of the commands used to read in,
investigate and subsequently segment array CGH data. The files
analysed represent 50 breast cancer cell lines obtained from Jessica M
Pole and Paul AW Edwards.

%%%make code chunk names


<<1,results=hide>>=
options(width=75)
library(snapCGH)
@

\Rpackage{snapCGH} is designed to be used in conjunction with \Rpackage{limma} and
so it will automatically load that library before proceeding.  In addition to \Rpackage{limma}, 
the following packages are also loaded: \Rpackage{GLAD}, \Rpackage{DNAcopy} and \Rpackage{aCGH}.
Each of these impliments an alternative segmentation method that may be applied to the data.\\

\section{Reading Data}

We read in the samples and create the initial RG object using the
following commands.

<<2, results=hide>>=
datadir <- system.file("testdata", package="snapCGH")
targets <- readTargets("targets.txt", path=datadir)
RG1 <- read.maimages(targets$FileName, path=datadir, source = "genepix")
@

%%The second of the above commands is very similar to the \texttt{read.maimages} function available in limma.
%%The only difference is that addition of the \texttt{TestChan} parameter.  


Information about the clones on the array (e.g. what part of the
genome they represent) can be read in separately using the
\Rfunction{read.clonesinfo} function. In order to do this it is necessary
to create a clones info file. Such a file (which can be created using
Excel and saved as a 'txt' file) must contain columns called Position
and Chr which give the position along a chromosome (in Mb) and the
chromosome to which a clone belongs. It must be ordered in the same
way as the clones are ordered in the genepix file. The information is
added to the \Robject{RG\$genes} object. The second command adds information
about the structure of the slide (blocks/rows/columns) to the \Robject{RG}
object.  Finally we read in a spot types file.  This file contains
information about the control status of particular spots on the array
and allows specific spots to be highlighted in many of the plotting
functions.  The content of a spot types file is covered extensively
within the \Rpackage{limma} manual.

<<3, results=hide>>=
RG1 <- read.clonesinfo("cloneinfo.txt", RG1, path=datadir)
RG1$printer <- getLayout(RG1$genes)
types <- readSpotTypes("SpotTypes.txt", path=datadir)
RG1$genes$Status <- controlStatus(types, RG1)

@

Commonly, when aCGH experiments are carried out the reference channel is dyed
using Cy5 and the test channel is dyed using Cy3.  This is the opposite way to expression data.
In order to take this into account we need to specify which channel is the reference
within our \Rclass{RGList}.  To do this we create a design vector with each column 
corresponding to an array in the experiment.  A value of 1 indicates that the Cy3 channel
is the reference, whilst a value of -1 equates to Cy5 being the reference.

<<3a>>=
RG1$design <- c(-1,-1)
@ 

We now proceed to use the function \Rfunction{backgroundCorrect} to remove 
the background intensity for each spot.  In this example we have chosen the 
method 'minimum' which subtracts the background value from the forground.
Any intensity which is zero or negative after the background subtraction is 
set equal to half the minimum of the positive corrected intensities for that array.
For other background correction methods please see the appropriate help file.

<<<3a>>=
RG2 <- backgroundCorrect(RG1, method="minimum")
@ 

%% Drop this step below?????? this should be a weight function

Next, we normalise the data. Here we will carry out a (global) median
normalisation. Other options for normalization methods are: \Rfunarg{none},
\Rfunarg{loess}, \Rfunarg{printtiploess}, \Rfunarg{composite} and \Rfunarg{robustspline}.  The output
of the normalization function is a new type of object called an
\Rclass{MAList}.  This is composed of the $log_{2}$ ratios,
intensities, gene and slide layout information which it gleans from
the \Robject{RG} object.

<<5>>=
MA <- normalizeWithinArrays(RG2, method="median")
@

We are now ready to process the data with the purpose of segmenting
the dataset into regions corresponding to sections of the genome where
there are the same number of copy number gains or losses.\\


Firstly, we use the \Rfunction{processCGH} to 'tidy up' the MAList
object. The \Rfunarg{method.of.averaging} option defines how clones of the 
same type should be averaged.  If this is specified the duplicates are removed 
following the averaging leaving only one occurence of each clone set.

<<6, results=hide>>=
MA2 <- processCGH(MA,method.of.averaging=mean)
@

We are now ready to fit the segmentation method. For larger data sets
this step can take a long time (several hours).  We fit the HMM using
the following commands.  The other segmentation methods included in
this library are \Rpackage{GLAD} and \Rpackage{DNAcopy}.  See manual pages for the functions
\Rfunction{runDNAcopy} and \Rfunction{runGLAD} for details of how to use
them.

<<7,results=hide>>=
SegInfo.Hom <- runHomHMM(MA2, criteria = "AIC")
@

We now deal with the fact that the HMM sometimes has a tendency to fit
states whose means are very close together. We overcome this problem
by merging states whose means are within a given threshold. There are
two different methods for carrying out the merging process.  For more
information on their differences please see the appropriate page in
the helpfiles.

<<9>>=
SegInfo.Hom.merged <- mergeStates(SegInfo.Hom, MergeType = 1)
@ 

We are now ready to use any of the plotting functions available in the
library.

\section{Plotting Functions}

The library comes with a variety of plotting functions that provide
visual representations of the data at various stages of the analysis
process.  Firstly we will look at the \Rfunction{genomePlot}
function. This function takes either an \Rclass{MAList} or a
\Rclass{SegList} object (in this example we've used an \Rclass{MAList}) and
plots the M-value for each gene against it's position on the genome.
The \Rfunarg{array} argument indicates which array is plotted.
This function utilizes the spot types data that was read in earlier to
highlight specific genes of interest.

<<label=11, include=FALSE>>=
genomePlot(MA2, array = 1)                                               
@ 

\begin{figure}
\begin{center}
<<label=11a, fig=TRUE,echo=FALSE>>=
<<11>>
@ 
\end{center}
\end{figure}

\pagebreak

It is also possible to
look at specific chromosomes, rather than the entire genome as in the
previous example.  Which particular chromosome is to be plotted is
specified using the \texttt{chrom.to.plot} argument.


<<label = 12, include=FALSE>>=
genomePlot(MA2, array = 1, chrom.to.plot = 8)
@ 

\begin{figure}[!ht]
\begin{center}
<<label=12a,fig=TRUE,echo=FALSE>>=
<<12>>
@ 
\end{center}
\end{figure}

Here we cluster the samples.  Again this function will except an
object of class \texttt{MAList} or \texttt{SegList}.  It is possible
to specify which chromosomes to cluster using the \texttt{vecchrom}
argument as well as defining the colours that represent areas of
amplification or deletion.  Please see the help file for more details.

<<label=13,include=FALSE>>=
heatmapGenome(MA2)
@ 

\begin{figure}[!ht]
\begin{center}
<<label=13a,fig=TRUE,echo=FALSE>>=
<<13>>
@ 
\end{center}
\end{figure}

\pagebreak

The \texttt{plotSegmentedGenome} function provides a visual
representation of the observed M-values overlayed with the predicted 
states produced by the segementation
algorithm.  It requires a \Rclass{SegList} as input.


<<label=14,include=FALSE>>=
plotSegmentedGenome(SegInfo.Hom.merged, array = 1)
@ 

\begin{figure}[!ht]
\begin{center}
<<label=14a,fig=TRUE,echo=FALSE>>=
<<14>>
@ 
\end{center}
\end{figure}

Using the argument \Rfunarg{chrom.to.plot} it is possible to specify individual
chromosomes to plot.  Additionally the function can accept more than one
\Robject{SegList} allowing visual comparison between segmentation methods.\\

The following example applies the DNAcopy algorithm to the data, merges it
and then plots both that segmentation method and the homogeneous HMM on the
same axis.

<<label=15, results=hide>>=
Seg.DNAcopy <- runDNAcopy(MA2)
SegInfo.DNAcopy.merged <- mergeStates(Seg.DNAcopy)
plotSegmentedGenome(SegInfo.Hom.merged, SegInfo.DNAcopy.merged, array = 1,
                    chrom.to.plot = 1, colors = c("blue", "green"))
@ 

\begin{figure}[!ht]
\begin{center}
<<label=16a,fig=TRUE,results = hide, echo=FALSE>>=
<<15>>
@ 
\end{center}
\end{figure}


\end{document}
